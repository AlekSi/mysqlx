// Code generated by protoc-gen-go. DO NOT EDIT.
// source: mysqlx_crud.proto

/*
Package mysqlx_crud is a generated protocol buffer package.

Basic CRUD operations

It is generated from these files:
	mysqlx_crud.proto

It has these top-level messages:
	Column
	Projection
	Collection
	Limit
	Order
	UpdateOperation
	Find
	Insert
	Update
	Delete
	CreateView
	ModifyView
	DropView
*/
package mysqlx_crud

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/AlekSi/mysqlx/internal/proto/mysqlx"
import Mysqlx_Expr "github.com/AlekSi/mysqlx/internal/proto/mysqlx_expr"
import Mysqlx_Datatypes "github.com/AlekSi/mysqlx/internal/proto/mysqlx_datatypes"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// DataModel to use for filters, names, ...
type DataModel int32

const (
	DataModel_DOCUMENT DataModel = 1
	DataModel_TABLE    DataModel = 2
)

var DataModel_name = map[int32]string{
	1: "DOCUMENT",
	2: "TABLE",
}
var DataModel_value = map[string]int32{
	"DOCUMENT": 1,
	"TABLE":    2,
}

func (x DataModel) Enum() *DataModel {
	p := new(DataModel)
	*p = x
	return p
}
func (x DataModel) String() string {
	return proto.EnumName(DataModel_name, int32(x))
}
func (x *DataModel) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DataModel_value, data, "DataModel")
	if err != nil {
		return err
	}
	*x = DataModel(value)
	return nil
}
func (DataModel) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// ViewAlgorithm defines how MySQL Server processes the view
type ViewAlgorithm int32

const (
	ViewAlgorithm_UNDEFINED ViewAlgorithm = 1
	ViewAlgorithm_MERGE     ViewAlgorithm = 2
	ViewAlgorithm_TEMPTABLE ViewAlgorithm = 3
)

var ViewAlgorithm_name = map[int32]string{
	1: "UNDEFINED",
	2: "MERGE",
	3: "TEMPTABLE",
}
var ViewAlgorithm_value = map[string]int32{
	"UNDEFINED": 1,
	"MERGE":     2,
	"TEMPTABLE": 3,
}

func (x ViewAlgorithm) Enum() *ViewAlgorithm {
	p := new(ViewAlgorithm)
	*p = x
	return p
}
func (x ViewAlgorithm) String() string {
	return proto.EnumName(ViewAlgorithm_name, int32(x))
}
func (x *ViewAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ViewAlgorithm_value, data, "ViewAlgorithm")
	if err != nil {
		return err
	}
	*x = ViewAlgorithm(value)
	return nil
}
func (ViewAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// ViewSqlSecurity defines the security context in which the view is going to be
// executed, this means that VIEW can be executed with current user permissions or
// with permissions of the uses who defined the VIEW
type ViewSqlSecurity int32

const (
	ViewSqlSecurity_INVOKER ViewSqlSecurity = 1
	ViewSqlSecurity_DEFINER ViewSqlSecurity = 2
)

var ViewSqlSecurity_name = map[int32]string{
	1: "INVOKER",
	2: "DEFINER",
}
var ViewSqlSecurity_value = map[string]int32{
	"INVOKER": 1,
	"DEFINER": 2,
}

func (x ViewSqlSecurity) Enum() *ViewSqlSecurity {
	p := new(ViewSqlSecurity)
	*p = x
	return p
}
func (x ViewSqlSecurity) String() string {
	return proto.EnumName(ViewSqlSecurity_name, int32(x))
}
func (x *ViewSqlSecurity) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ViewSqlSecurity_value, data, "ViewSqlSecurity")
	if err != nil {
		return err
	}
	*x = ViewSqlSecurity(value)
	return nil
}
func (ViewSqlSecurity) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// ViewCheckOption limits the write operations done on a `VIEW`
// (`INSERT`, `UPDATE`, `DELETE`) to rows in which the `WHERE` clause is `TRUE`
type ViewCheckOption int32

const (
	ViewCheckOption_LOCAL    ViewCheckOption = 1
	ViewCheckOption_CASCADED ViewCheckOption = 2
)

var ViewCheckOption_name = map[int32]string{
	1: "LOCAL",
	2: "CASCADED",
}
var ViewCheckOption_value = map[string]int32{
	"LOCAL":    1,
	"CASCADED": 2,
}

func (x ViewCheckOption) Enum() *ViewCheckOption {
	p := new(ViewCheckOption)
	*p = x
	return p
}
func (x ViewCheckOption) String() string {
	return proto.EnumName(ViewCheckOption_name, int32(x))
}
func (x *ViewCheckOption) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ViewCheckOption_value, data, "ViewCheckOption")
	if err != nil {
		return err
	}
	*x = ViewCheckOption(value)
	return nil
}
func (ViewCheckOption) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type Order_Direction int32

const (
	Order_ASC  Order_Direction = 1
	Order_DESC Order_Direction = 2
)

var Order_Direction_name = map[int32]string{
	1: "ASC",
	2: "DESC",
}
var Order_Direction_value = map[string]int32{
	"ASC":  1,
	"DESC": 2,
}

func (x Order_Direction) Enum() *Order_Direction {
	p := new(Order_Direction)
	*p = x
	return p
}
func (x Order_Direction) String() string {
	return proto.EnumName(Order_Direction_name, int32(x))
}
func (x *Order_Direction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Order_Direction_value, data, "Order_Direction")
	if err != nil {
		return err
	}
	*x = Order_Direction(value)
	return nil
}
func (Order_Direction) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type UpdateOperation_UpdateType int32

const (
	UpdateOperation_SET          UpdateOperation_UpdateType = 1
	UpdateOperation_ITEM_REMOVE  UpdateOperation_UpdateType = 2
	UpdateOperation_ITEM_SET     UpdateOperation_UpdateType = 3
	UpdateOperation_ITEM_REPLACE UpdateOperation_UpdateType = 4
	UpdateOperation_ITEM_MERGE   UpdateOperation_UpdateType = 5
	UpdateOperation_ARRAY_INSERT UpdateOperation_UpdateType = 6
	UpdateOperation_ARRAY_APPEND UpdateOperation_UpdateType = 7
	UpdateOperation_MERGE_PATCH  UpdateOperation_UpdateType = 8
)

var UpdateOperation_UpdateType_name = map[int32]string{
	1: "SET",
	2: "ITEM_REMOVE",
	3: "ITEM_SET",
	4: "ITEM_REPLACE",
	5: "ITEM_MERGE",
	6: "ARRAY_INSERT",
	7: "ARRAY_APPEND",
	8: "MERGE_PATCH",
}
var UpdateOperation_UpdateType_value = map[string]int32{
	"SET":          1,
	"ITEM_REMOVE":  2,
	"ITEM_SET":     3,
	"ITEM_REPLACE": 4,
	"ITEM_MERGE":   5,
	"ARRAY_INSERT": 6,
	"ARRAY_APPEND": 7,
	"MERGE_PATCH":  8,
}

func (x UpdateOperation_UpdateType) Enum() *UpdateOperation_UpdateType {
	p := new(UpdateOperation_UpdateType)
	*p = x
	return p
}
func (x UpdateOperation_UpdateType) String() string {
	return proto.EnumName(UpdateOperation_UpdateType_name, int32(x))
}
func (x *UpdateOperation_UpdateType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UpdateOperation_UpdateType_value, data, "UpdateOperation_UpdateType")
	if err != nil {
		return err
	}
	*x = UpdateOperation_UpdateType(value)
	return nil
}
func (UpdateOperation_UpdateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{5, 0}
}

type Find_RowLock int32

const (
	Find_SHARED_LOCK    Find_RowLock = 1
	Find_EXCLUSIVE_LOCK Find_RowLock = 2
)

var Find_RowLock_name = map[int32]string{
	1: "SHARED_LOCK",
	2: "EXCLUSIVE_LOCK",
}
var Find_RowLock_value = map[string]int32{
	"SHARED_LOCK":    1,
	"EXCLUSIVE_LOCK": 2,
}

func (x Find_RowLock) Enum() *Find_RowLock {
	p := new(Find_RowLock)
	*p = x
	return p
}
func (x Find_RowLock) String() string {
	return proto.EnumName(Find_RowLock_name, int32(x))
}
func (x *Find_RowLock) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Find_RowLock_value, data, "Find_RowLock")
	if err != nil {
		return err
	}
	*x = Find_RowLock(value)
	return nil
}
func (Find_RowLock) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

// column definition
type Column struct {
	Name             *string                         `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Alias            *string                         `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
	DocumentPath     []*Mysqlx_Expr.DocumentPathItem `protobuf:"bytes,3,rep,name=document_path,json=documentPath" json:"document_path,omitempty"`
	XXX_unrecognized []byte                          `json:"-"`
}

func (m *Column) Reset()                    { *m = Column{} }
func (m *Column) String() string            { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()               {}
func (*Column) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Column) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Column) GetAlias() string {
	if m != nil && m.Alias != nil {
		return *m.Alias
	}
	return ""
}

func (m *Column) GetDocumentPath() []*Mysqlx_Expr.DocumentPathItem {
	if m != nil {
		return m.DocumentPath
	}
	return nil
}

// a projection
//
// :param source: the expression identifying an element from the source data
//                which can include a column identifier or any expression
// :param alias: optional alias. Required for DOCUMENTs (clients may use
//              the source string as default)
type Projection struct {
	Source           *Mysqlx_Expr.Expr `protobuf:"bytes,1,req,name=source" json:"source,omitempty"`
	Alias            *string           `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Projection) Reset()                    { *m = Projection{} }
func (m *Projection) String() string            { return proto.CompactTextString(m) }
func (*Projection) ProtoMessage()               {}
func (*Projection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Projection) GetSource() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Projection) GetAlias() string {
	if m != nil && m.Alias != nil {
		return *m.Alias
	}
	return ""
}

// collection
type Collection struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Schema           *string `protobuf:"bytes,2,opt,name=schema" json:"schema,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Collection) Reset()                    { *m = Collection{} }
func (m *Collection) String() string            { return proto.CompactTextString(m) }
func (*Collection) ProtoMessage()               {}
func (*Collection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Collection) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Collection) GetSchema() string {
	if m != nil && m.Schema != nil {
		return *m.Schema
	}
	return ""
}

// limit
//
// :param row_count: maximum rows to filter
// :param offset: maximum rows to skip before applying the row_count
type Limit struct {
	RowCount         *uint64 `protobuf:"varint,1,req,name=row_count,json=rowCount" json:"row_count,omitempty"`
	Offset           *uint64 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Limit) Reset()                    { *m = Limit{} }
func (m *Limit) String() string            { return proto.CompactTextString(m) }
func (*Limit) ProtoMessage()               {}
func (*Limit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Limit) GetRowCount() uint64 {
	if m != nil && m.RowCount != nil {
		return *m.RowCount
	}
	return 0
}

func (m *Limit) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

// sort order
type Order struct {
	Expr             *Mysqlx_Expr.Expr `protobuf:"bytes,1,req,name=expr" json:"expr,omitempty"`
	Direction        *Order_Direction  `protobuf:"varint,2,opt,name=direction,enum=Mysqlx.Crud.Order_Direction,def=1" json:"direction,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Order) Reset()                    { *m = Order{} }
func (m *Order) String() string            { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()               {}
func (*Order) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

const Default_Order_Direction Order_Direction = Order_ASC

func (m *Order) GetExpr() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Order) GetDirection() Order_Direction {
	if m != nil && m.Direction != nil {
		return *m.Direction
	}
	return Default_Order_Direction
}

// update operations
//
// :param source: specification of the value to be updated
//      if data_model is TABLE, a column name may be specified and also a document path, if the column has type JSON
//      if data_model is DOCUMENT, only document paths are allowed
//      in both cases, schema and table must be not set
// :param operation: the type of operation to be performed
// :param value: an expression to be computed as the new value for the operation
type UpdateOperation struct {
	Source           *Mysqlx_Expr.ColumnIdentifier `protobuf:"bytes,1,req,name=source" json:"source,omitempty"`
	Operation        *UpdateOperation_UpdateType   `protobuf:"varint,2,req,name=operation,enum=Mysqlx.Crud.UpdateOperation_UpdateType" json:"operation,omitempty"`
	Value            *Mysqlx_Expr.Expr             `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *UpdateOperation) Reset()                    { *m = UpdateOperation{} }
func (m *UpdateOperation) String() string            { return proto.CompactTextString(m) }
func (*UpdateOperation) ProtoMessage()               {}
func (*UpdateOperation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UpdateOperation) GetSource() *Mysqlx_Expr.ColumnIdentifier {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *UpdateOperation) GetOperation() UpdateOperation_UpdateType {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return UpdateOperation_SET
}

func (m *UpdateOperation) GetValue() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.Value
	}
	return nil
}

// Find Documents/Rows in a Collection/Table
//
// .. uml::
//
//   client -> server: Find
//   ... one or more Resultset ...
//
// :param collection: collection to insert into
// :param data_model: datamodel that the operations refer to
// :param projection: list of column projections that shall be returned
// :param args: values for parameters used in filter expression
// :param criteria: filter criteria
// :param limit: numbers of rows that shall be skipped and returned
// :param order: sort-order in which the rows/document shall be returned in
// :param grouping: column expression list for aggregation (GROUP BY)
// :param grouping_criteria: filter criteria for aggregated groups
// :param locking: perform row locking on matches
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Find struct {
	Collection       *Collection                `protobuf:"bytes,2,req,name=collection" json:"collection,omitempty"`
	DataModel        *DataModel                 `protobuf:"varint,3,opt,name=data_model,json=dataModel,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Projection       []*Projection              `protobuf:"bytes,4,rep,name=projection" json:"projection,omitempty"`
	Criteria         *Mysqlx_Expr.Expr          `protobuf:"bytes,5,opt,name=criteria" json:"criteria,omitempty"`
	Args             []*Mysqlx_Datatypes.Scalar `protobuf:"bytes,11,rep,name=args" json:"args,omitempty"`
	Limit            *Limit                     `protobuf:"bytes,6,opt,name=limit" json:"limit,omitempty"`
	Order            []*Order                   `protobuf:"bytes,7,rep,name=order" json:"order,omitempty"`
	Grouping         []*Mysqlx_Expr.Expr        `protobuf:"bytes,8,rep,name=grouping" json:"grouping,omitempty"`
	GroupingCriteria *Mysqlx_Expr.Expr          `protobuf:"bytes,9,opt,name=grouping_criteria,json=groupingCriteria" json:"grouping_criteria,omitempty"`
	Locking          *Find_RowLock              `protobuf:"varint,12,opt,name=locking,enum=Mysqlx.Crud.Find_RowLock" json:"locking,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *Find) Reset()                    { *m = Find{} }
func (m *Find) String() string            { return proto.CompactTextString(m) }
func (*Find) ProtoMessage()               {}
func (*Find) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Find) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Find) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Find) GetProjection() []*Projection {
	if m != nil {
		return m.Projection
	}
	return nil
}

func (m *Find) GetCriteria() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.Criteria
	}
	return nil
}

func (m *Find) GetArgs() []*Mysqlx_Datatypes.Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Find) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Find) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Find) GetGrouping() []*Mysqlx_Expr.Expr {
	if m != nil {
		return m.Grouping
	}
	return nil
}

func (m *Find) GetGroupingCriteria() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.GroupingCriteria
	}
	return nil
}

func (m *Find) GetLocking() Find_RowLock {
	if m != nil && m.Locking != nil {
		return *m.Locking
	}
	return Find_SHARED_LOCK
}

// Insert documents/rows into a collection/table
//
// :param collection: collection to insert into
// :param data_model: datamodel that the operations refer to
// :param projection: name of the columns to insert data into (empty if data_model is DOCUMENT)
// :param row: set of rows to insert into the collection/table (a single expression with a JSON document literal or an OBJECT expression)
// :param args: values for parameters used in row expressions
// :param upsert: true if this should be treated as an Upsert (that is, update on duplicate key)
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Insert struct {
	Collection       *Collection                `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	DataModel        *DataModel                 `protobuf:"varint,2,opt,name=data_model,json=dataModel,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Projection       []*Column                  `protobuf:"bytes,3,rep,name=projection" json:"projection,omitempty"`
	Row              []*Insert_TypedRow         `protobuf:"bytes,4,rep,name=row" json:"row,omitempty"`
	Args             []*Mysqlx_Datatypes.Scalar `protobuf:"bytes,5,rep,name=args" json:"args,omitempty"`
	Upsert           *bool                      `protobuf:"varint,6,opt,name=upsert,def=0" json:"upsert,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *Insert) Reset()                    { *m = Insert{} }
func (m *Insert) String() string            { return proto.CompactTextString(m) }
func (*Insert) ProtoMessage()               {}
func (*Insert) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

const Default_Insert_Upsert bool = false

func (m *Insert) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Insert) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Insert) GetProjection() []*Column {
	if m != nil {
		return m.Projection
	}
	return nil
}

func (m *Insert) GetRow() []*Insert_TypedRow {
	if m != nil {
		return m.Row
	}
	return nil
}

func (m *Insert) GetArgs() []*Mysqlx_Datatypes.Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Insert) GetUpsert() bool {
	if m != nil && m.Upsert != nil {
		return *m.Upsert
	}
	return Default_Insert_Upsert
}

type Insert_TypedRow struct {
	Field            []*Mysqlx_Expr.Expr `protobuf:"bytes,1,rep,name=field" json:"field,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *Insert_TypedRow) Reset()                    { *m = Insert_TypedRow{} }
func (m *Insert_TypedRow) String() string            { return proto.CompactTextString(m) }
func (*Insert_TypedRow) ProtoMessage()               {}
func (*Insert_TypedRow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *Insert_TypedRow) GetField() []*Mysqlx_Expr.Expr {
	if m != nil {
		return m.Field
	}
	return nil
}

// Update documents/rows in a collection/table
//
// :param collection: collection to change
// :param data_model: datamodel that the operations refer to
// :param criteria: filter expression to match rows that the operations will apply on
// :param args: values for parameters used in filter expression
// :param limit: limits the number of rows to match
// :param order: specifies order of matched rows
// :param operation: list of operations to be applied. Valid operations will depend on the data_model.
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Update struct {
	Collection       *Collection                `protobuf:"bytes,2,req,name=collection" json:"collection,omitempty"`
	DataModel        *DataModel                 `protobuf:"varint,3,opt,name=data_model,json=dataModel,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Criteria         *Mysqlx_Expr.Expr          `protobuf:"bytes,4,opt,name=criteria" json:"criteria,omitempty"`
	Args             []*Mysqlx_Datatypes.Scalar `protobuf:"bytes,8,rep,name=args" json:"args,omitempty"`
	Limit            *Limit                     `protobuf:"bytes,5,opt,name=limit" json:"limit,omitempty"`
	Order            []*Order                   `protobuf:"bytes,6,rep,name=order" json:"order,omitempty"`
	Operation        []*UpdateOperation         `protobuf:"bytes,7,rep,name=operation" json:"operation,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (m *Update) String() string            { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Update) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Update) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Update) GetCriteria() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.Criteria
	}
	return nil
}

func (m *Update) GetArgs() []*Mysqlx_Datatypes.Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Update) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Update) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Update) GetOperation() []*UpdateOperation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// Delete documents/rows from a Collection/Table
//
// :param collection: collection to change
// :param data_model: datamodel that the operations refer to
// :param criteria: filter expression to match rows that the operations will apply on
// :param args: values for parameters used in filter expression
// :param limit: limits the number of rows to match
// :param order: specifies order of matched rows
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Delete struct {
	Collection       *Collection                `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	DataModel        *DataModel                 `protobuf:"varint,2,opt,name=data_model,json=dataModel,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Criteria         *Mysqlx_Expr.Expr          `protobuf:"bytes,3,opt,name=criteria" json:"criteria,omitempty"`
	Args             []*Mysqlx_Datatypes.Scalar `protobuf:"bytes,6,rep,name=args" json:"args,omitempty"`
	Limit            *Limit                     `protobuf:"bytes,4,opt,name=limit" json:"limit,omitempty"`
	Order            []*Order                   `protobuf:"bytes,5,rep,name=order" json:"order,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *Delete) Reset()                    { *m = Delete{} }
func (m *Delete) String() string            { return proto.CompactTextString(m) }
func (*Delete) ProtoMessage()               {}
func (*Delete) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Delete) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Delete) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Delete) GetCriteria() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.Criteria
	}
	return nil
}

func (m *Delete) GetArgs() []*Mysqlx_Datatypes.Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Delete) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Delete) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

type CreateView struct {
	Collection       *Collection      `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	Definer          *string          `protobuf:"bytes,2,opt,name=definer" json:"definer,omitempty"`
	Algorithm        *ViewAlgorithm   `protobuf:"varint,3,opt,name=algorithm,enum=Mysqlx.Crud.ViewAlgorithm,def=1" json:"algorithm,omitempty"`
	Security         *ViewSqlSecurity `protobuf:"varint,4,opt,name=security,enum=Mysqlx.Crud.ViewSqlSecurity,def=2" json:"security,omitempty"`
	Check            *ViewCheckOption `protobuf:"varint,5,opt,name=check,enum=Mysqlx.Crud.ViewCheckOption" json:"check,omitempty"`
	Column           []string         `protobuf:"bytes,6,rep,name=column" json:"column,omitempty"`
	Stmt             *Find            `protobuf:"bytes,7,req,name=stmt" json:"stmt,omitempty"`
	ReplaceExisting  *bool            `protobuf:"varint,8,opt,name=replace_existing,json=replaceExisting,def=0" json:"replace_existing,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *CreateView) Reset()                    { *m = CreateView{} }
func (m *CreateView) String() string            { return proto.CompactTextString(m) }
func (*CreateView) ProtoMessage()               {}
func (*CreateView) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

const Default_CreateView_Algorithm ViewAlgorithm = ViewAlgorithm_UNDEFINED
const Default_CreateView_Security ViewSqlSecurity = ViewSqlSecurity_DEFINER
const Default_CreateView_ReplaceExisting bool = false

func (m *CreateView) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *CreateView) GetDefiner() string {
	if m != nil && m.Definer != nil {
		return *m.Definer
	}
	return ""
}

func (m *CreateView) GetAlgorithm() ViewAlgorithm {
	if m != nil && m.Algorithm != nil {
		return *m.Algorithm
	}
	return Default_CreateView_Algorithm
}

func (m *CreateView) GetSecurity() ViewSqlSecurity {
	if m != nil && m.Security != nil {
		return *m.Security
	}
	return Default_CreateView_Security
}

func (m *CreateView) GetCheck() ViewCheckOption {
	if m != nil && m.Check != nil {
		return *m.Check
	}
	return ViewCheckOption_LOCAL
}

func (m *CreateView) GetColumn() []string {
	if m != nil {
		return m.Column
	}
	return nil
}

func (m *CreateView) GetStmt() *Find {
	if m != nil {
		return m.Stmt
	}
	return nil
}

func (m *CreateView) GetReplaceExisting() bool {
	if m != nil && m.ReplaceExisting != nil {
		return *m.ReplaceExisting
	}
	return Default_CreateView_ReplaceExisting
}

type ModifyView struct {
	Collection       *Collection      `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	Definer          *string          `protobuf:"bytes,2,opt,name=definer" json:"definer,omitempty"`
	Algorithm        *ViewAlgorithm   `protobuf:"varint,3,opt,name=algorithm,enum=Mysqlx.Crud.ViewAlgorithm" json:"algorithm,omitempty"`
	Security         *ViewSqlSecurity `protobuf:"varint,4,opt,name=security,enum=Mysqlx.Crud.ViewSqlSecurity" json:"security,omitempty"`
	Check            *ViewCheckOption `protobuf:"varint,5,opt,name=check,enum=Mysqlx.Crud.ViewCheckOption" json:"check,omitempty"`
	Column           []string         `protobuf:"bytes,6,rep,name=column" json:"column,omitempty"`
	Stmt             *Find            `protobuf:"bytes,7,opt,name=stmt" json:"stmt,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *ModifyView) Reset()                    { *m = ModifyView{} }
func (m *ModifyView) String() string            { return proto.CompactTextString(m) }
func (*ModifyView) ProtoMessage()               {}
func (*ModifyView) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ModifyView) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *ModifyView) GetDefiner() string {
	if m != nil && m.Definer != nil {
		return *m.Definer
	}
	return ""
}

func (m *ModifyView) GetAlgorithm() ViewAlgorithm {
	if m != nil && m.Algorithm != nil {
		return *m.Algorithm
	}
	return ViewAlgorithm_UNDEFINED
}

func (m *ModifyView) GetSecurity() ViewSqlSecurity {
	if m != nil && m.Security != nil {
		return *m.Security
	}
	return ViewSqlSecurity_INVOKER
}

func (m *ModifyView) GetCheck() ViewCheckOption {
	if m != nil && m.Check != nil {
		return *m.Check
	}
	return ViewCheckOption_LOCAL
}

func (m *ModifyView) GetColumn() []string {
	if m != nil {
		return m.Column
	}
	return nil
}

func (m *ModifyView) GetStmt() *Find {
	if m != nil {
		return m.Stmt
	}
	return nil
}

type DropView struct {
	Collection       *Collection `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	IfExists         *bool       `protobuf:"varint,2,opt,name=if_exists,json=ifExists,def=0" json:"if_exists,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *DropView) Reset()                    { *m = DropView{} }
func (m *DropView) String() string            { return proto.CompactTextString(m) }
func (*DropView) ProtoMessage()               {}
func (*DropView) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

const Default_DropView_IfExists bool = false

func (m *DropView) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *DropView) GetIfExists() bool {
	if m != nil && m.IfExists != nil {
		return *m.IfExists
	}
	return Default_DropView_IfExists
}

func init() {
	proto.RegisterType((*Column)(nil), "Mysqlx.Crud.Column")
	proto.RegisterType((*Projection)(nil), "Mysqlx.Crud.Projection")
	proto.RegisterType((*Collection)(nil), "Mysqlx.Crud.Collection")
	proto.RegisterType((*Limit)(nil), "Mysqlx.Crud.Limit")
	proto.RegisterType((*Order)(nil), "Mysqlx.Crud.Order")
	proto.RegisterType((*UpdateOperation)(nil), "Mysqlx.Crud.UpdateOperation")
	proto.RegisterType((*Find)(nil), "Mysqlx.Crud.Find")
	proto.RegisterType((*Insert)(nil), "Mysqlx.Crud.Insert")
	proto.RegisterType((*Insert_TypedRow)(nil), "Mysqlx.Crud.Insert.TypedRow")
	proto.RegisterType((*Update)(nil), "Mysqlx.Crud.Update")
	proto.RegisterType((*Delete)(nil), "Mysqlx.Crud.Delete")
	proto.RegisterType((*CreateView)(nil), "Mysqlx.Crud.CreateView")
	proto.RegisterType((*ModifyView)(nil), "Mysqlx.Crud.ModifyView")
	proto.RegisterType((*DropView)(nil), "Mysqlx.Crud.DropView")
	proto.RegisterEnum("Mysqlx.Crud.DataModel", DataModel_name, DataModel_value)
	proto.RegisterEnum("Mysqlx.Crud.ViewAlgorithm", ViewAlgorithm_name, ViewAlgorithm_value)
	proto.RegisterEnum("Mysqlx.Crud.ViewSqlSecurity", ViewSqlSecurity_name, ViewSqlSecurity_value)
	proto.RegisterEnum("Mysqlx.Crud.ViewCheckOption", ViewCheckOption_name, ViewCheckOption_value)
	proto.RegisterEnum("Mysqlx.Crud.Order_Direction", Order_Direction_name, Order_Direction_value)
	proto.RegisterEnum("Mysqlx.Crud.UpdateOperation_UpdateType", UpdateOperation_UpdateType_name, UpdateOperation_UpdateType_value)
	proto.RegisterEnum("Mysqlx.Crud.Find_RowLock", Find_RowLock_name, Find_RowLock_value)
}

func init() { proto.RegisterFile("mysqlx_crud.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1256 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x5f, 0x6f, 0xdb, 0x54,
	0x14, 0x97, 0x1d, 0x3b, 0x89, 0x4f, 0xba, 0xd6, 0xbd, 0x9b, 0x36, 0xaf, 0xb0, 0x51, 0x59, 0xa0,
	0x95, 0x02, 0xd6, 0x94, 0x69, 0xa2, 0xaa, 0x10, 0xc8, 0xb3, 0x3d, 0x16, 0x2d, 0x69, 0xa2, 0x9b,
	0xb4, 0x82, 0xa7, 0xc8, 0xd8, 0x37, 0xad, 0x37, 0x3b, 0xf6, 0xae, 0x9d, 0x75, 0xfd, 0x06, 0x48,
	0x3c, 0x20, 0xf1, 0x45, 0x78, 0xe7, 0x03, 0xf0, 0xc4, 0xd7, 0xe0, 0x05, 0xbe, 0x04, 0xba, 0xd7,
	0x76, 0x12, 0x67, 0x2d, 0x6b, 0x87, 0xca, 0x4b, 0xe5, 0x7b, 0xce, 0xef, 0x9c, 0x73, 0xcf, 0xef,
	0xfc, 0xe9, 0x0d, 0x6c, 0x46, 0x67, 0xe9, 0xab, 0xf0, 0xcd, 0xd8, 0xa3, 0x33, 0xdf, 0x48, 0x68,
	0x9c, 0xc5, 0xa8, 0xd5, 0xe3, 0x22, 0xc3, 0xa2, 0x33, 0x7f, 0x6b, 0x2d, 0xd7, 0xe7, 0xaa, 0xad,
	0x12, 0x4d, 0xde, 0x24, 0xb4, 0x10, 0xdd, 0x2e, 0x44, 0xbe, 0x9b, 0xb9, 0xd9, 0x59, 0x42, 0xd2,
	0x5c, 0xae, 0xbf, 0x86, 0xba, 0x15, 0x87, 0xb3, 0x68, 0x8a, 0x10, 0x48, 0x53, 0x37, 0x22, 0x9a,
	0xb0, 0x2d, 0xec, 0x28, 0x98, 0x7f, 0xa3, 0x5b, 0x20, 0xbb, 0x61, 0xe0, 0xa6, 0x9a, 0xc8, 0x85,
	0xf9, 0x01, 0x3d, 0x81, 0x1b, 0x7e, 0xec, 0xcd, 0x22, 0x32, 0xcd, 0xc6, 0x89, 0x9b, 0x9d, 0x68,
	0xb5, 0xed, 0xda, 0x4e, 0xab, 0x7d, 0xcf, 0x28, 0x6e, 0xe4, 0xb0, 0xb0, 0x76, 0x81, 0x18, 0xb8,
	0xd9, 0x49, 0x27, 0x23, 0x11, 0x5e, 0xf3, 0x97, 0x24, 0x7a, 0x0f, 0x60, 0x40, 0xe3, 0x17, 0xc4,
	0xcb, 0x82, 0x78, 0x8a, 0x3e, 0x85, 0x7a, 0x1a, 0xcf, 0xa8, 0xc7, 0xa2, 0x8b, 0x3b, 0xad, 0xf6,
	0x66, 0xc5, 0x15, 0xfb, 0x83, 0x0b, 0xc0, 0xf9, 0x57, 0xd2, 0xf7, 0x00, 0xac, 0x38, 0x0c, 0x0b,
	0x77, 0x8b, 0x54, 0xc4, 0x79, 0x2a, 0xb7, 0xa1, 0x9e, 0x7a, 0x27, 0x24, 0x72, 0x0b, 0xc3, 0xe2,
	0xa4, 0x7f, 0x05, 0x72, 0x37, 0x88, 0x82, 0x0c, 0x7d, 0x00, 0x0a, 0x8d, 0x4f, 0xc7, 0x5e, 0x3c,
	0x9b, 0x66, 0xdc, 0x52, 0xc2, 0x4d, 0x1a, 0x9f, 0x5a, 0xec, 0xcc, 0xac, 0xe3, 0xc9, 0x24, 0x25,
	0x19, 0xb7, 0x96, 0x70, 0x71, 0xd2, 0x7f, 0x16, 0x40, 0xee, 0x53, 0x9f, 0x50, 0xf4, 0x09, 0x48,
	0x8c, 0xee, 0x8b, 0x13, 0xe0, 0x6a, 0xf4, 0x0d, 0x28, 0x7e, 0x40, 0xf3, 0x7b, 0x72, 0x5f, 0xeb,
	0xed, 0x0f, 0x8d, 0xa5, 0x4a, 0x1a, 0xdc, 0x9b, 0x61, 0x97, 0x98, 0xfd, 0x9a, 0x39, 0xb4, 0xf0,
	0xc2, 0x46, 0xbf, 0x0f, 0xca, 0x5c, 0x89, 0x1a, 0xc0, 0xd4, 0xaa, 0x80, 0x9a, 0x20, 0xd9, 0xce,
	0xd0, 0x52, 0x45, 0xfd, 0x77, 0x11, 0x36, 0x0e, 0x13, 0xdf, 0xcd, 0x48, 0x3f, 0x21, 0xd4, 0xe5,
	0xb0, 0xc7, 0x2b, 0xf4, 0x56, 0x2b, 0x95, 0xd7, 0xbf, 0xe3, 0x93, 0x69, 0x16, 0x4c, 0x02, 0xb2,
	0xa0, 0xda, 0x01, 0x25, 0x2e, 0x7d, 0x68, 0xe2, 0xb6, 0xb8, 0xb3, 0xde, 0x7e, 0x50, 0xb9, 0xeb,
	0x4a, 0x9c, 0xe2, 0x3c, 0x3a, 0x4b, 0x08, 0x5e, 0x58, 0xa2, 0x07, 0x20, 0xbf, 0x76, 0xc3, 0x19,
	0xd1, 0x6a, 0xdb, 0xc2, 0xf9, 0xd4, 0xe4, 0x7a, 0xfd, 0x27, 0x01, 0x60, 0xe1, 0x82, 0x25, 0x37,
	0x74, 0x46, 0xaa, 0x80, 0x36, 0xa0, 0xd5, 0x19, 0x39, 0xbd, 0x31, 0x76, 0x7a, 0xfd, 0x23, 0x47,
	0x15, 0xd1, 0x1a, 0x34, 0xb9, 0x80, 0xa9, 0x6b, 0x48, 0x85, 0xb5, 0x42, 0x3d, 0xe8, 0x9a, 0x96,
	0xa3, 0x4a, 0x68, 0x1d, 0x80, 0x4b, 0x7a, 0x0e, 0xfe, 0xd6, 0x51, 0x65, 0x86, 0x30, 0x31, 0x36,
	0xbf, 0x1f, 0x77, 0x0e, 0x86, 0x0e, 0x1e, 0xa9, 0xf5, 0x85, 0xc4, 0x1c, 0x0c, 0x9c, 0x03, 0x5b,
	0x6d, 0xb0, 0x20, 0x1c, 0x3e, 0x1e, 0x98, 0x23, 0xeb, 0x99, 0xda, 0xd4, 0x7f, 0x93, 0x40, 0x7a,
	0x1a, 0x4c, 0x7d, 0xf4, 0x25, 0x80, 0x37, 0xef, 0x2d, 0xce, 0x43, 0xab, 0x7d, 0xa7, 0xc2, 0xc3,
	0xa2, 0xf5, 0xf0, 0x12, 0x14, 0x3d, 0x06, 0x60, 0xe3, 0x36, 0x8e, 0x62, 0x9f, 0x84, 0x3c, 0xfb,
	0xf5, 0xf6, 0xed, 0x8a, 0xa1, 0xed, 0x66, 0x6e, 0x8f, 0x69, 0xb1, 0xe2, 0x97, 0x9f, 0x2c, 0x5e,
	0x32, 0x1f, 0x0d, 0x4d, 0xe2, 0xb3, 0x55, 0x8d, 0xb7, 0x98, 0x1c, 0xbc, 0x04, 0x45, 0x5f, 0x40,
	0xd3, 0xa3, 0x41, 0x46, 0x68, 0xe0, 0x6a, 0xf2, 0x45, 0x5c, 0xcf, 0x21, 0xe8, 0x73, 0x90, 0x5c,
	0x7a, 0x9c, 0x6a, 0x2d, 0x1e, 0x41, 0x2b, 0xa1, 0xf6, 0x7c, 0x43, 0x0c, 0x3d, 0x37, 0x74, 0x29,
	0xe6, 0x28, 0xb4, 0x03, 0x72, 0xc8, 0xe6, 0x44, 0xab, 0x73, 0xcf, 0xa8, 0x72, 0x21, 0x3e, 0x41,
	0x38, 0x07, 0x30, 0x64, 0xcc, 0x9a, 0x58, 0x6b, 0x70, 0xc7, 0xe8, 0xed, 0xf6, 0xc6, 0x39, 0x80,
	0x5d, 0xf8, 0x98, 0xc6, 0xb3, 0x24, 0x98, 0x1e, 0x6b, 0x4d, 0x0e, 0x3e, 0xef, 0xc2, 0x25, 0x04,
	0x7d, 0x0d, 0x9b, 0xe5, 0xf7, 0x78, 0x9e, 0xa8, 0x72, 0x51, 0xa2, 0x6a, 0x89, 0xb5, 0xca, 0x84,
	0x1f, 0x41, 0x23, 0x8c, 0xbd, 0x97, 0x2c, 0xda, 0x1a, 0x2f, 0xc6, 0xdd, 0xca, 0xd5, 0x58, 0xb1,
	0x0d, 0x1c, 0x9f, 0x76, 0x63, 0xef, 0x25, 0x2e, 0x91, 0xba, 0x01, 0x8d, 0x42, 0xc6, 0x5a, 0x64,
	0xf8, 0xcc, 0xc4, 0x8e, 0x3d, 0xee, 0xf6, 0xad, 0xe7, 0xaa, 0x80, 0x10, 0xac, 0x3b, 0xdf, 0x59,
	0xdd, 0xc3, 0x61, 0xe7, 0xc8, 0xc9, 0x65, 0xe2, 0xbe, 0xf4, 0xe3, 0x5f, 0x0f, 0x37, 0xf5, 0x3f,
	0x45, 0xa8, 0x77, 0xa6, 0x29, 0xa1, 0xd9, 0x4a, 0xfb, 0x08, 0xef, 0xdb, 0x3e, 0xe2, 0x65, 0xdb,
	0xe7, 0x51, 0xa5, 0x7d, 0xf2, 0xd5, 0x7c, 0x73, 0x35, 0xde, 0x2c, 0xaa, 0xb6, 0x8e, 0x01, 0x35,
	0x1a, 0x9f, 0x16, 0xcd, 0x56, 0x5d, 0x48, 0x79, 0x1a, 0x06, 0x1b, 0x49, 0x1f, 0xc7, 0xa7, 0x98,
	0x01, 0xe7, 0xbd, 0x23, 0x5f, 0xaa, 0x77, 0xee, 0x41, 0x7d, 0x96, 0x30, 0x2f, 0xbc, 0x79, 0x9a,
	0xfb, 0xf2, 0xc4, 0x0d, 0x53, 0x82, 0x0b, 0xe1, 0xd6, 0x23, 0x68, 0x96, 0xde, 0xd9, 0xb2, 0x98,
	0x04, 0x24, 0xf4, 0x35, 0xe1, 0xa2, 0x7e, 0xc8, 0xf5, 0x9c, 0x67, 0xa4, 0xff, 0x2d, 0x42, 0x3d,
	0x5f, 0x19, 0xff, 0xfb, 0x98, 0x2e, 0x4f, 0x9b, 0x74, 0xf9, 0x69, 0x6b, 0x5e, 0x6d, 0xda, 0xe4,
	0x4b, 0x4f, 0x5b, 0xfd, 0x5d, 0xd3, 0xb6, 0xbf, 0xbc, 0xce, 0x1b, 0xe7, 0x54, 0x7a, 0x65, 0x9d,
	0x2f, 0xed, 0x70, 0xce, 0xf6, 0x4d, 0xfd, 0x57, 0x11, 0xea, 0x36, 0x09, 0xc9, 0x5b, 0x6c, 0x5f,
	0x7f, 0x57, 0x2f, 0xb3, 0x5d, 0xbb, 0x3c, 0xdb, 0xf5, 0xab, 0xb1, 0x2d, 0x5d, 0x9a, 0x6d, 0xf9,
	0x1d, 0x6c, 0x73, 0xc6, 0x6e, 0xe9, 0xbf, 0xd4, 0x00, 0x2c, 0x4a, 0xdc, 0x8c, 0x1c, 0x05, 0xe4,
	0xf4, 0xfd, 0x59, 0xd3, 0xa0, 0xe1, 0x93, 0x49, 0x30, 0x25, 0xb4, 0x78, 0xbe, 0x94, 0x47, 0x64,
	0x81, 0xe2, 0x86, 0xc7, 0x31, 0x0d, 0xb2, 0x93, 0xa8, 0x68, 0xde, 0xad, 0x8a, 0x47, 0x16, 0xd8,
	0x2c, 0x11, 0xfb, 0xca, 0xe1, 0x81, 0xed, 0x3c, 0xed, 0x1c, 0x38, 0x36, 0x5e, 0xd8, 0x21, 0x13,
	0x9a, 0x29, 0xf1, 0x66, 0x34, 0xc8, 0xce, 0x38, 0x07, 0xab, 0x8f, 0x12, 0xe6, 0x63, 0xf8, 0x2a,
	0x1c, 0x16, 0x98, 0xfd, 0x46, 0xee, 0x03, 0xe3, 0xb9, 0x19, 0x6a, 0x83, 0xec, 0x9d, 0x10, 0xef,
	0x25, 0xef, 0xd8, 0xf3, 0xec, 0x2d, 0xa6, 0xed, 0x27, 0x3c, 0xb5, 0x1c, 0xca, 0x5e, 0x55, 0x1e,
	0xdf, 0x45, 0xbc, 0x4e, 0x0a, 0x2e, 0x4e, 0xec, 0x2d, 0x95, 0x66, 0x51, 0xa6, 0x35, 0xaa, 0x6f,
	0xa9, 0xf9, 0x96, 0xc6, 0x5c, 0x8d, 0x1e, 0x82, 0x4a, 0x49, 0x12, 0xba, 0x1e, 0x19, 0x93, 0x37,
	0x41, 0x9a, 0xe5, 0xff, 0x46, 0x96, 0x16, 0xcc, 0x46, 0xa1, 0x76, 0x0a, 0x2d, 0x2f, 0xca, 0x7d,
	0xfd, 0x0f, 0x11, 0xa0, 0x17, 0xfb, 0xc1, 0xe4, 0xec, 0xba, 0x8a, 0xb2, 0x77, 0xa5, 0xa2, 0x2c,
	0x57, 0x62, 0xef, 0x6a, 0x95, 0xb8, 0xf6, 0x02, 0x08, 0xff, 0x52, 0x00, 0x4e, 0xe7, 0x47, 0x7a,
	0x04, 0x4d, 0x9b, 0xc6, 0xc9, 0x7f, 0xe3, 0x52, 0x07, 0x25, 0x98, 0xe4, 0x65, 0xcc, 0x9f, 0xf6,
	0xf3, 0x22, 0x36, 0x83, 0x09, 0xaf, 0x5f, 0xca, 0xc3, 0x6d, 0xef, 0x7e, 0x0c, 0xca, 0x7c, 0x43,
	0xb0, 0x97, 0xa0, 0xdd, 0xb7, 0x0e, 0x7b, 0xce, 0x01, 0x7b, 0x28, 0x2a, 0x20, 0x8f, 0xcc, 0x27,
	0x5d, 0x47, 0x15, 0x77, 0xf7, 0xe0, 0x46, 0x85, 0x63, 0x74, 0x03, 0x16, 0xad, 0x9f, 0x43, 0xf3,
	0xd7, 0xa1, 0xc8, 0x34, 0x23, 0xa7, 0x37, 0xc8, 0x2d, 0x6b, 0xbb, 0x9f, 0xc1, 0xc6, 0x0a, 0xc9,
	0xa8, 0x05, 0x8d, 0xce, 0xc1, 0x51, 0xff, 0xb9, 0x83, 0x55, 0x81, 0x1d, 0x8a, 0xee, 0x57, 0xc5,
	0xdd, 0xdd, 0x1c, 0xbc, 0x44, 0x2d, 0xf3, 0xdc, 0xed, 0x5b, 0x66, 0x57, 0x15, 0xd8, 0xed, 0x2c,
	0x73, 0x68, 0x99, 0xb6, 0x63, 0xab, 0xe2, 0x93, 0xbb, 0x70, 0xc7, 0x8b, 0x23, 0x83, 0xff, 0x10,
	0x33, 0xbc, 0x17, 0x46, 0xf1, 0x6b, 0xed, 0x87, 0xd9, 0xe4, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xcd, 0xff, 0xf5, 0xc0, 0xdf, 0x0d, 0x00, 0x00,
}
