// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mysqlx_resultset.proto

package mysqlx_resultset

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/AlekSi/mysqlx/internal/proto/mysqlx"

import github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// a hint about the higher-level encoding of a BYTES field
//
// ====== ====== ===========
// type   value  description
// ====== ====== ===========
// BYTES  0x0001 GEOMETRY (WKB encoding)
// BYTES  0x0002 JSON (text encoding)
// BYTES  0x0003 XML (text encoding)
// ====== ====== ===========
//
// .. note::
//   this list isn't comprehensive. As guideline: the field's value is expected
//   to pass a validator check on client and server if this field is set.
//   If the server adds more internal datatypes that rely on BLOB storage
//   like image manipulation, seeking into complex types in BLOBs, ... more
//   types will be added.
type ContentType_BYTES int32

const (
	ContentType_BYTES_GEOMETRY ContentType_BYTES = 1
	ContentType_BYTES_JSON     ContentType_BYTES = 2
	ContentType_BYTES_XML      ContentType_BYTES = 3
)

var ContentType_BYTES_name = map[int32]string{
	1: "GEOMETRY",
	2: "JSON",
	3: "XML",
}
var ContentType_BYTES_value = map[string]int32{
	"GEOMETRY": 1,
	"JSON":     2,
	"XML":      3,
}

func (x ContentType_BYTES) Enum() *ContentType_BYTES {
	p := new(ContentType_BYTES)
	*p = x
	return p
}
func (x ContentType_BYTES) String() string {
	return proto.EnumName(ContentType_BYTES_name, int32(x))
}
func (x *ContentType_BYTES) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContentType_BYTES_value, data, "ContentType_BYTES")
	if err != nil {
		return err
	}
	*x = ContentType_BYTES(value)
	return nil
}
func (ContentType_BYTES) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_resultset_348287d7ae183020, []int{0}
}

// a hint about the higher-level encoding of a DATETIME field
//
// ======   ====== ===========
// type     value  description
// ======== ====== ===========
// DATE     0x0001 DATETIME contains only date part
// DATETIME 0x0002 DATETIME contains both date and time parts
// ======   ====== ===========
type ContentType_DATETIME int32

const (
	ContentType_DATETIME_DATE     ContentType_DATETIME = 1
	ContentType_DATETIME_DATETIME ContentType_DATETIME = 2
)

var ContentType_DATETIME_name = map[int32]string{
	1: "DATE",
	2: "DATETIME",
}
var ContentType_DATETIME_value = map[string]int32{
	"DATE":     1,
	"DATETIME": 2,
}

func (x ContentType_DATETIME) Enum() *ContentType_DATETIME {
	p := new(ContentType_DATETIME)
	*p = x
	return p
}
func (x ContentType_DATETIME) String() string {
	return proto.EnumName(ContentType_DATETIME_name, int32(x))
}
func (x *ContentType_DATETIME) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContentType_DATETIME_value, data, "ContentType_DATETIME")
	if err != nil {
		return err
	}
	*x = ContentType_DATETIME(value)
	return nil
}
func (ContentType_DATETIME) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_resultset_348287d7ae183020, []int{1}
}

type ColumnMetaData_FieldType int32

const (
	ColumnMetaData_SINT     ColumnMetaData_FieldType = 1
	ColumnMetaData_UINT     ColumnMetaData_FieldType = 2
	ColumnMetaData_DOUBLE   ColumnMetaData_FieldType = 5
	ColumnMetaData_FLOAT    ColumnMetaData_FieldType = 6
	ColumnMetaData_BYTES    ColumnMetaData_FieldType = 7
	ColumnMetaData_TIME     ColumnMetaData_FieldType = 10
	ColumnMetaData_DATETIME ColumnMetaData_FieldType = 12
	ColumnMetaData_SET      ColumnMetaData_FieldType = 15
	ColumnMetaData_ENUM     ColumnMetaData_FieldType = 16
	ColumnMetaData_BIT      ColumnMetaData_FieldType = 17
	ColumnMetaData_DECIMAL  ColumnMetaData_FieldType = 18
)

var ColumnMetaData_FieldType_name = map[int32]string{
	1:  "SINT",
	2:  "UINT",
	5:  "DOUBLE",
	6:  "FLOAT",
	7:  "BYTES",
	10: "TIME",
	12: "DATETIME",
	15: "SET",
	16: "ENUM",
	17: "BIT",
	18: "DECIMAL",
}
var ColumnMetaData_FieldType_value = map[string]int32{
	"SINT":     1,
	"UINT":     2,
	"DOUBLE":   5,
	"FLOAT":    6,
	"BYTES":    7,
	"TIME":     10,
	"DATETIME": 12,
	"SET":      15,
	"ENUM":     16,
	"BIT":      17,
	"DECIMAL":  18,
}

func (x ColumnMetaData_FieldType) Enum() *ColumnMetaData_FieldType {
	p := new(ColumnMetaData_FieldType)
	*p = x
	return p
}
func (x ColumnMetaData_FieldType) String() string {
	return proto.EnumName(ColumnMetaData_FieldType_name, int32(x))
}
func (x *ColumnMetaData_FieldType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ColumnMetaData_FieldType_value, data, "ColumnMetaData_FieldType")
	if err != nil {
		return err
	}
	*x = ColumnMetaData_FieldType(value)
	return nil
}
func (ColumnMetaData_FieldType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_resultset_348287d7ae183020, []int{3, 0}
}

// resultsets are finished, OUT paramset is next
type FetchDoneMoreOutParams struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchDoneMoreOutParams) Reset()         { *m = FetchDoneMoreOutParams{} }
func (m *FetchDoneMoreOutParams) String() string { return proto.CompactTextString(m) }
func (*FetchDoneMoreOutParams) ProtoMessage()    {}
func (*FetchDoneMoreOutParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_resultset_348287d7ae183020, []int{0}
}
func (m *FetchDoneMoreOutParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchDoneMoreOutParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchDoneMoreOutParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FetchDoneMoreOutParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchDoneMoreOutParams.Merge(dst, src)
}
func (m *FetchDoneMoreOutParams) XXX_Size() int {
	return m.Size()
}
func (m *FetchDoneMoreOutParams) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchDoneMoreOutParams.DiscardUnknown(m)
}

var xxx_messageInfo_FetchDoneMoreOutParams proto.InternalMessageInfo

// resultset and out-params are finished, but more resultsets available
type FetchDoneMoreResultsets struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchDoneMoreResultsets) Reset()         { *m = FetchDoneMoreResultsets{} }
func (m *FetchDoneMoreResultsets) String() string { return proto.CompactTextString(m) }
func (*FetchDoneMoreResultsets) ProtoMessage()    {}
func (*FetchDoneMoreResultsets) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_resultset_348287d7ae183020, []int{1}
}
func (m *FetchDoneMoreResultsets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchDoneMoreResultsets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchDoneMoreResultsets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FetchDoneMoreResultsets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchDoneMoreResultsets.Merge(dst, src)
}
func (m *FetchDoneMoreResultsets) XXX_Size() int {
	return m.Size()
}
func (m *FetchDoneMoreResultsets) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchDoneMoreResultsets.DiscardUnknown(m)
}

var xxx_messageInfo_FetchDoneMoreResultsets proto.InternalMessageInfo

// all resultsets are finished
type FetchDone struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchDone) Reset()         { *m = FetchDone{} }
func (m *FetchDone) String() string { return proto.CompactTextString(m) }
func (*FetchDone) ProtoMessage()    {}
func (*FetchDone) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_resultset_348287d7ae183020, []int{2}
}
func (m *FetchDone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchDone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchDone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FetchDone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchDone.Merge(dst, src)
}
func (m *FetchDone) XXX_Size() int {
	return m.Size()
}
func (m *FetchDone) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchDone.DiscardUnknown(m)
}

var xxx_messageInfo_FetchDone proto.InternalMessageInfo

// meta data of a Column
//
// .. note:: the encoding used for the different ``bytes`` fields in the meta data is externally
//   controlled.
//   .. seealso:: https://dev.mysql.com/doc/refman/8.0/en/charset-connection.html
//
// .. note::
//   The server may not set the ``original_{table|name}`` fields if they are equal to the plain
//   ``{table|name}`` field.
//
//   A client has to reconstruct it like::
//
//     if .original_name is empty and .name is not empty:
//       .original_name = .name
//
//     if .original_table is empty and .table is not empty:
//       .original_table = .table
//
// .. note::
//   ``compact metadata format`` can be requested by the client. In that case only ``.type`` is set and
//   all other fields are empty.
//
//
// :param type:
//   .. table:: Expected Datatype of Mysqlx.Resultset.Row per SQL Type for non NULL values
//
//     ================= ============ ======= ========== ====== ========
//     SQL Type          .type        .length .frac_dig  .flags .charset
//     ================= ============ ======= ========== ====== ========
//     TINY              SINT         x
//     TINY UNSIGNED     UINT         x                  x
//     SHORT             SINT         x
//     SHORT UNSIGNED    UINT         x                  x
//     INT24             SINT         x
//     INT24 UNSIGNED    UINT         x                  x
//     INT               SINT         x
//     INT UNSIGNED      UINT         x                  x
//     LONGLONG          SINT         x
//     LONGLONG UNSIGNED UINT         x                  x
//     DOUBLE            DOUBLE       x       x          x
//     FLOAT             FLOAT        x       x          x
//     DECIMAL           DECIMAL      x       x          x
//     VARCHAR,CHAR,...  BYTES        x                  x      x
//     GEOMETRY          BYTES
//     TIME              TIME         x
//     DATE              DATETIME     x
//     DATETIME          DATETIME     x
//     YEAR              UINT         x                  x
//     TIMESTAMP         DATETIME     x
//     SET               SET                                    x
//     ENUM              ENUM                                   x
//     NULL              BYTES
//     BIT               BIT          x
//     ================= ============ ======= ========== ====== ========
//
//   .. note:: the SQL "NULL" value is sent as an empty field value in :protobuf:msg:`Mysqlx.Resultset::Row`
//   .. seealso:: protobuf encoding of primitive datatypes are decribed in https://developers.google.com/protocol-buffers/docs/encoding
//
//   SINT
//
//     ``.length``
//       maximum number of displayable decimal digits (including minus sign) of the type
//
//       .. note::
//         valid range is 0-255, but usually you'll see 1-20
//
//       =============== ==
//       SQL Type        max digits per type
//       =============== ==
//       TINY SIGNED      4
//       SHORT SIGNED     6
//       INT24 SIGNED     8
//       INT SIGNED      11
//       LONGLONG SIGNED 20
//       =============== ==
//
//       .. seealso:: definition of ``M`` in https://dev.mysql.com/doc/refman/8.0/en/numeric-type-overview.html
//
//     ``value``
//       variable length encoded signed 64 integer
//
//   UINT
//
//     ``.flags & 1`` (zerofill)
//       the client has to left pad with 0's up to .length
//
//     ``.length``
//       maximum number of displayable decimal digits of the type
//
//       .. note::
//         valid range is 0-255, but usually you'll see 1-20
//
//       ================= ==
//       SQL Type          max digits per type
//       ================= ==
//       TINY UNSIGNED      3
//       SHORT UNSIGNED     5
//       INT24 UNSIGNED     8
//       INT UNSIGNED      10
//       LONGLONG UNSIGNED 20
//       ================= ==
//
//       .. seealso:: definition of ``M`` in https://dev.mysql.com/doc/refman/8.0/en/numeric-type-overview.html
//
//     ``value``
//       variable length encoded unsigned 64 integer
//
//   BIT
//
//     ``.length``
//       maximum number of displayable binary digits
//
//       .. note:: valid range for M of the ``BIT`` type is 1 - 64
//       .. seealso:: https://dev.mysql.com/doc/refman/8.0/en/numeric-type-overview.html
//
//     ``value``
//       variable length encoded unsigned 64 integer
//
//   DOUBLE
//
//     ``.length``
//       maximum number of displayable decimal digits (including the decimal point and ``.fractional_digits``)
//
//     ``.fractional_digits``
//       maximum number of displayable decimal digits following the decimal point
//
//     ``value``
//       encoded as Protobuf's 'double'
//
//   FLOAT
//
//     ``.length``
//       maximum number of displayable decimal digits (including the decimal point and ``.fractional_digits``)
//
//     ``.fractional_digits``
//       maximum number of displayable decimal digits following the decimal point
//
//     ``value``
//       encoded as Protobuf's 'float'
//
//   BYTES, ENUM
//     BYTES is used for all opaque byte strings that may have a charset
//
//       * TINYBLOB, BLOB, MEDIUMBLOB, LONGBLOB
//       * TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT
//       * VARCHAR, VARBINARY
//       * CHAR, BINARY
//       * ENUM
//
//     ``.length``
//       the maximum length of characters of the underlying type
//
//     ``.flags & 1`` (rightpad)
//       if the length of the field is less than ``.length``, the receiver is
//       supposed to add padding characters to the right end of the string.
//       If the ``.charset`` is "binary", the padding character is ``0x00``,
//       otherwise it is a space character as defined by that character set.
//
//       ============= ======= ======== =======
//       SQL Type      .length .charset .flags
//       ============= ======= ======== =======
//       TINYBLOB      256     binary
//       BLOB          65535   binary
//       VARCHAR(32)   32      utf8
//       VARBINARY(32) 32      utf8_bin
//       BINARY(32)    32      binary   rightpad
//       CHAR(32)      32      utf8     rightpad
//       ============= ======= ======== =======
//
//     ``value``
//       sequence of bytes with added one extra '\0' byte at the end. To obtain the
//       original string, the extra '\0' should be removed.
//       .. note:: the length of the string can be acquired with protobuf's field length() method
//         length of sequence-of-bytes = length-of-field - 1
//       .. note:: the extra byte allows to distinguish between a NULL and empty byte sequence
//
//   TIME
//     A time value.
//
//     ``value``
//       the following bytes sequence:
//
//         ``| negate [ | hour | [ | minutes | [ | seconds | [ | useconds | ]]]]``
//
//       * negate - one byte, should be one of: 0x00 for "+", 0x01 for "-"
//       * hour - optional variable length encoded unsigned64 value for the hour
//       * minutes - optional variable length encoded unsigned64 value for the minutes
//       * seconds - optional variable length encoded unsigned64 value for the seconds
//       * useconds - optional variable length encoded unsigned64 value for the microseconds
//
//       .. seealso:: protobuf encoding in https://developers.google.com/protocol-buffers/docs/encoding
//       .. note:: hour, minutes, seconds, useconds are optional if all the values to the right are 0
//
//       Example: 0x00 -> +00:00:00.000000
//
//   DATETIME
//     A date or date and time value.
//
//     ``value``
//       a sequence of variants, arranged as follows:
//
//         ``| year | month | day | [ | hour | [ | minutes | [ | seconds | [ | useconds | ]]]]``
//
//       * year - variable length encoded unsigned64 value for the year
//       * month - variable length encoded unsigned64 value for the month
//       * day - variable length encoded unsigned64 value for the day
//       * hour - optional variable length encoded unsigned64 value for the hour
//       * minutes - optional variable length encoded unsigned64 value for the minutes
//       * seconds - optional variable length encoded unsigned64 value for the seconds
//       * useconds - optional variable length encoded unsigned64 value for the microseconds
//
//       .. note:: hour, minutes, seconds, useconds are optional if all the values to the right are 0
//
//     ``.flags & 1`` (timestamp)
//
//       ============= =======
//       SQL Type      .flags
//       ============= =======
//       DATETIME
//       TIMESTAMP     1
//
//   DECIMAL
//     An arbitrary length number. The number is encoded as a single byte
//     indicating the position of the decimal point followed by the Packed BCD
//     encoded number. Packed BCD is used to simplify conversion to and
//     from strings and other native arbitrary precision math datatypes.
//     .. seealso:: packed BCD in https://en.wikipedia.org/wiki/Binary-coded_decimal
//
//     ``.length``
//       maximum number of displayable decimal digits (*excluding* the decimal point and sign, but including ``.fractional_digits``)
//
//       .. note:: should be in the range of 1 - 65
//
//     ``.fractional_digits``
//       is the decimal digits to display out of length
//
//       .. note:: should be in the range of 0 - 30
//
//     ``value``
//       the following bytes sequence:
//
//         ``| scale | BCD | sign | [0x0] |``
//
//       * scale - 8bit scale value (number of decimal digit after the '.')
//       * BCD - BCD encoded digits (4 bits for each digit)
//       * sign - sign encoded on 4 bits (0xc = "+", 0xd = "-")
//       * 0x0 - last 4bits if length(digits) % 2 == 0
//
//       Example: x04 0x12 0x34 0x01 0xd0 -> -12.3401
//
//   SET
//     A list of strings representing a SET of values.
//
//     ``value``
//       A sequence of 0 or more of protobuf's bytes (length prepended octets) or one of
//       the special sequences with a predefined meaning listed below.
//
//       Example (length of the bytes array shown in brackets):
//         * ``[0]`` - the NULL value
//         * ``[1] 0x00`` - a set containing a blank string ''
//         * ``[1] 0x01`` - this would be an invalid value, but is to be treated as the empty set
//         * ``[2] 0x01 0x00`` - a set with a single item, which is the '\0' character
//         * ``[8] 0x03 F O O 0x03 B A R`` - a set with 2 items: FOO,BAR
//
//
// :param name: name of the column
// :param original_name: name of the column before an alias was applied
// :param table: name of the table the column orginates from
// :param original_table: name of the table the column orginates from before an alias was applied
// :param schema: schema the column originates from
// :param catalog:
//   catalog the schema originates from
//
//   .. note::
//     as there is current no support for catalogs in MySQL, don't expect this field to be set.
//     In the MySQL C/S protocol the field had the value ``def`` all the time.
//
// :param fractional_digits: displayed factional decimal digits for floating point and fixed point numbers
// :param length: maximum count of displayable characters of .type
// :param flags:
//   ``.type`` specific flags
//
//   ======= ====== ===========
//   type    value  description
//   ======= ====== ===========
//   UINT    0x0001 zerofill
//   DOUBLE  0x0001 unsigned
//   FLOAT   0x0001 unsigned
//   DECIMAL 0x0001 unsigned
//   BYTES   0x0001 rightpad
//   ======= ====== ===========
//
//   ====== ================
//   value  description
//   ====== ================
//   0x0010 NOT_NULL
//   0x0020 PRIMARY_KEY
//   0x0040 UNIQUE_KEY
//   0x0080 MULTIPLE_KEY
//   0x0100 AUTO_INCREMENT
//   ====== ================
//
//   default: 0
// :param content_type:
//   a hint about the higher-level encoding of a BYTES field, for more informations
//   please refer to Mysqlx.Resultset.ContentType_BYTES enum.
//
type ColumnMetaData struct {
	// datatype of the field in a row
	Type                 *ColumnMetaData_FieldType `protobuf:"varint,1,req,name=type,enum=Mysqlx.Resultset.ColumnMetaData_FieldType" json:"type,omitempty"`
	Name                 []byte                    `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	OriginalName         []byte                    `protobuf:"bytes,3,opt,name=original_name,json=originalName" json:"original_name,omitempty"`
	Table                []byte                    `protobuf:"bytes,4,opt,name=table" json:"table,omitempty"`
	OriginalTable        []byte                    `protobuf:"bytes,5,opt,name=original_table,json=originalTable" json:"original_table,omitempty"`
	Schema               []byte                    `protobuf:"bytes,6,opt,name=schema" json:"schema,omitempty"`
	Catalog              []byte                    `protobuf:"bytes,7,opt,name=catalog" json:"catalog,omitempty"`
	Collation            *uint64                   `protobuf:"varint,8,opt,name=collation" json:"collation,omitempty"`
	FractionalDigits     *uint32                   `protobuf:"varint,9,opt,name=fractional_digits,json=fractionalDigits" json:"fractional_digits,omitempty"`
	Length               *uint32                   `protobuf:"varint,10,opt,name=length" json:"length,omitempty"`
	Flags                *uint32                   `protobuf:"varint,11,opt,name=flags" json:"flags,omitempty"`
	ContentType          *uint32                   `protobuf:"varint,12,opt,name=content_type,json=contentType" json:"content_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ColumnMetaData) Reset()         { *m = ColumnMetaData{} }
func (m *ColumnMetaData) String() string { return proto.CompactTextString(m) }
func (*ColumnMetaData) ProtoMessage()    {}
func (*ColumnMetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_resultset_348287d7ae183020, []int{3}
}
func (m *ColumnMetaData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnMetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnMetaData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ColumnMetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnMetaData.Merge(dst, src)
}
func (m *ColumnMetaData) XXX_Size() int {
	return m.Size()
}
func (m *ColumnMetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnMetaData.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnMetaData proto.InternalMessageInfo

func (m *ColumnMetaData) GetType() ColumnMetaData_FieldType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ColumnMetaData_SINT
}

func (m *ColumnMetaData) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *ColumnMetaData) GetOriginalName() []byte {
	if m != nil {
		return m.OriginalName
	}
	return nil
}

func (m *ColumnMetaData) GetTable() []byte {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *ColumnMetaData) GetOriginalTable() []byte {
	if m != nil {
		return m.OriginalTable
	}
	return nil
}

func (m *ColumnMetaData) GetSchema() []byte {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *ColumnMetaData) GetCatalog() []byte {
	if m != nil {
		return m.Catalog
	}
	return nil
}

func (m *ColumnMetaData) GetCollation() uint64 {
	if m != nil && m.Collation != nil {
		return *m.Collation
	}
	return 0
}

func (m *ColumnMetaData) GetFractionalDigits() uint32 {
	if m != nil && m.FractionalDigits != nil {
		return *m.FractionalDigits
	}
	return 0
}

func (m *ColumnMetaData) GetLength() uint32 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

func (m *ColumnMetaData) GetFlags() uint32 {
	if m != nil && m.Flags != nil {
		return *m.Flags
	}
	return 0
}

func (m *ColumnMetaData) GetContentType() uint32 {
	if m != nil && m.ContentType != nil {
		return *m.ContentType
	}
	return 0
}

//   Row in a Resultset
//
//   a row is represented as a list of fields encoded as byte blobs.
//   Blob of size 0 represents the NULL value. Otherwise, if it contains at least
//   one byte, it encodes a non-null value of the field using encoding appropriate for the
//   type of the value given by ``ColumnMetadata``, as specified
//   in the :protobuf:msg:`Mysqlx.Resultset::ColumnMetaData` description.
//
type Row struct {
	Field                [][]byte `protobuf:"bytes,1,rep,name=field" json:"field,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Row) Reset()         { *m = Row{} }
func (m *Row) String() string { return proto.CompactTextString(m) }
func (*Row) ProtoMessage()    {}
func (*Row) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_resultset_348287d7ae183020, []int{4}
}
func (m *Row) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Row) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Row.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Row) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Row.Merge(dst, src)
}
func (m *Row) XXX_Size() int {
	return m.Size()
}
func (m *Row) XXX_DiscardUnknown() {
	xxx_messageInfo_Row.DiscardUnknown(m)
}

var xxx_messageInfo_Row proto.InternalMessageInfo

func (m *Row) GetField() [][]byte {
	if m != nil {
		return m.Field
	}
	return nil
}

func init() {
	proto.RegisterType((*FetchDoneMoreOutParams)(nil), "Mysqlx.Resultset.FetchDoneMoreOutParams")
	proto.RegisterType((*FetchDoneMoreResultsets)(nil), "Mysqlx.Resultset.FetchDoneMoreResultsets")
	proto.RegisterType((*FetchDone)(nil), "Mysqlx.Resultset.FetchDone")
	proto.RegisterType((*ColumnMetaData)(nil), "Mysqlx.Resultset.ColumnMetaData")
	proto.RegisterType((*Row)(nil), "Mysqlx.Resultset.Row")
	proto.RegisterEnum("Mysqlx.Resultset.ContentType_BYTES", ContentType_BYTES_name, ContentType_BYTES_value)
	proto.RegisterEnum("Mysqlx.Resultset.ContentType_DATETIME", ContentType_DATETIME_name, ContentType_DATETIME_value)
	proto.RegisterEnum("Mysqlx.Resultset.ColumnMetaData_FieldType", ColumnMetaData_FieldType_name, ColumnMetaData_FieldType_value)
}
func (m *FetchDoneMoreOutParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchDoneMoreOutParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FetchDoneMoreResultsets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchDoneMoreResultsets) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FetchDone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchDone) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColumnMetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnMetaData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMysqlxResultset(dAtA, i, uint64(*m.Type))
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMysqlxResultset(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.OriginalName != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMysqlxResultset(dAtA, i, uint64(len(m.OriginalName)))
		i += copy(dAtA[i:], m.OriginalName)
	}
	if m.Table != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMysqlxResultset(dAtA, i, uint64(len(m.Table)))
		i += copy(dAtA[i:], m.Table)
	}
	if m.OriginalTable != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMysqlxResultset(dAtA, i, uint64(len(m.OriginalTable)))
		i += copy(dAtA[i:], m.OriginalTable)
	}
	if m.Schema != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMysqlxResultset(dAtA, i, uint64(len(m.Schema)))
		i += copy(dAtA[i:], m.Schema)
	}
	if m.Catalog != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMysqlxResultset(dAtA, i, uint64(len(m.Catalog)))
		i += copy(dAtA[i:], m.Catalog)
	}
	if m.Collation != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMysqlxResultset(dAtA, i, uint64(*m.Collation))
	}
	if m.FractionalDigits != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMysqlxResultset(dAtA, i, uint64(*m.FractionalDigits))
	}
	if m.Length != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMysqlxResultset(dAtA, i, uint64(*m.Length))
	}
	if m.Flags != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMysqlxResultset(dAtA, i, uint64(*m.Flags))
	}
	if m.ContentType != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMysqlxResultset(dAtA, i, uint64(*m.ContentType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Row) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Row) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Field) > 0 {
		for _, b := range m.Field {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMysqlxResultset(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMysqlxResultset(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FetchDoneMoreOutParams) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchDoneMoreResultsets) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchDone) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColumnMetaData) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMysqlxResultset(uint64(*m.Type))
	}
	if m.Name != nil {
		l = len(m.Name)
		n += 1 + l + sovMysqlxResultset(uint64(l))
	}
	if m.OriginalName != nil {
		l = len(m.OriginalName)
		n += 1 + l + sovMysqlxResultset(uint64(l))
	}
	if m.Table != nil {
		l = len(m.Table)
		n += 1 + l + sovMysqlxResultset(uint64(l))
	}
	if m.OriginalTable != nil {
		l = len(m.OriginalTable)
		n += 1 + l + sovMysqlxResultset(uint64(l))
	}
	if m.Schema != nil {
		l = len(m.Schema)
		n += 1 + l + sovMysqlxResultset(uint64(l))
	}
	if m.Catalog != nil {
		l = len(m.Catalog)
		n += 1 + l + sovMysqlxResultset(uint64(l))
	}
	if m.Collation != nil {
		n += 1 + sovMysqlxResultset(uint64(*m.Collation))
	}
	if m.FractionalDigits != nil {
		n += 1 + sovMysqlxResultset(uint64(*m.FractionalDigits))
	}
	if m.Length != nil {
		n += 1 + sovMysqlxResultset(uint64(*m.Length))
	}
	if m.Flags != nil {
		n += 1 + sovMysqlxResultset(uint64(*m.Flags))
	}
	if m.ContentType != nil {
		n += 1 + sovMysqlxResultset(uint64(*m.ContentType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Row) Size() (n int) {
	var l int
	_ = l
	if len(m.Field) > 0 {
		for _, b := range m.Field {
			l = len(b)
			n += 1 + l + sovMysqlxResultset(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMysqlxResultset(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMysqlxResultset(x uint64) (n int) {
	return sovMysqlxResultset(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FetchDoneMoreOutParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMysqlxResultset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchDoneMoreOutParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchDoneMoreOutParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMysqlxResultset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMysqlxResultset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchDoneMoreResultsets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMysqlxResultset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchDoneMoreResultsets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchDoneMoreResultsets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMysqlxResultset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMysqlxResultset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchDone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMysqlxResultset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchDone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchDone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMysqlxResultset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMysqlxResultset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnMetaData) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMysqlxResultset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnMetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnMetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v ColumnMetaData_FieldType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ColumnMetaData_FieldType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMysqlxResultset
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMysqlxResultset
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalName = append(m.OriginalName[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginalName == nil {
				m.OriginalName = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMysqlxResultset
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = append(m.Table[:0], dAtA[iNdEx:postIndex]...)
			if m.Table == nil {
				m.Table = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalTable", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMysqlxResultset
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalTable = append(m.OriginalTable[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginalTable == nil {
				m.OriginalTable = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMysqlxResultset
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema[:0], dAtA[iNdEx:postIndex]...)
			if m.Schema == nil {
				m.Schema = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Catalog", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMysqlxResultset
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Catalog = append(m.Catalog[:0], dAtA[iNdEx:postIndex]...)
			if m.Catalog == nil {
				m.Catalog = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collation", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Collation = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FractionalDigits", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FractionalDigits = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Length = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flags = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContentType = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMysqlxResultset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMysqlxResultset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Row) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMysqlxResultset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Row: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Row: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMysqlxResultset
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = append(m.Field, make([]byte, postIndex-iNdEx))
			copy(m.Field[len(m.Field)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMysqlxResultset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMysqlxResultset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMysqlxResultset(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMysqlxResultset
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMysqlxResultset
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMysqlxResultset
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMysqlxResultset
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMysqlxResultset(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMysqlxResultset = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMysqlxResultset   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("mysqlx_resultset.proto", fileDescriptor_mysqlx_resultset_348287d7ae183020)
}

var fileDescriptor_mysqlx_resultset_348287d7ae183020 = []byte{
	// 551 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x53, 0xcd, 0x8e, 0xd2, 0x40,
	0x1c, 0xb7, 0x50, 0x60, 0xf9, 0x6f, 0x17, 0x87, 0xc9, 0x66, 0xb7, 0x31, 0x06, 0xd9, 0x1a, 0x13,
	0x5c, 0x93, 0xc6, 0x18, 0x4f, 0x1e, 0x4c, 0x80, 0x16, 0x83, 0xa1, 0x60, 0x4a, 0x49, 0xdc, 0x13,
	0x99, 0xed, 0x0e, 0x50, 0x33, 0xed, 0x60, 0x3b, 0x44, 0xb9, 0xfa, 0x04, 0x1e, 0xbd, 0xf9, 0x3a,
	0x1e, 0x7d, 0x04, 0x83, 0x37, 0x9f, 0xc2, 0xcc, 0x94, 0x0f, 0xf1, 0xf6, 0xfb, 0x9a, 0x99, 0xdf,
	0xfc, 0xdb, 0x81, 0x8b, 0x78, 0x9d, 0x7d, 0x64, 0x9f, 0xa7, 0x29, 0xcd, 0x56, 0x4c, 0x64, 0x54,
	0xd8, 0xcb, 0x94, 0x0b, 0x8e, 0x91, 0xa7, 0x74, 0xdb, 0xdf, 0xe9, 0x0f, 0x8c, 0x3c, 0x99, 0xfb,
	0x56, 0x03, 0x2e, 0x7a, 0x54, 0x84, 0x0b, 0x87, 0x27, 0xd4, 0xe3, 0x29, 0x1d, 0xad, 0xc4, 0x3b,
	0x92, 0x92, 0x38, 0x7b, 0xa5, 0x7f, 0xfd, 0xf3, 0x1c, 0x5b, 0x8f, 0xe0, 0xf2, 0xc8, 0xdf, 0xef,
	0x93, 0x07, 0x90, 0x55, 0x87, 0xea, 0x3e, 0xa0, 0xa4, 0x9a, 0xf5, 0x5d, 0x87, 0x5a, 0x97, 0xb3,
	0x55, 0x9c, 0x78, 0x54, 0x10, 0x87, 0x08, 0x82, 0x5f, 0x83, 0x2e, 0xd6, 0x4b, 0x6a, 0x6a, 0xcd,
	0x42, 0xab, 0xf6, 0xe2, 0xda, 0xfe, 0xbf, 0x95, 0x7d, 0x9c, 0xb7, 0x7b, 0x11, 0x65, 0x77, 0xc1,
	0x7a, 0x49, 0x7d, 0xb5, 0x0e, 0x63, 0xd0, 0x13, 0x12, 0x53, 0xb3, 0xd0, 0xd4, 0x5a, 0x86, 0xaf,
	0x30, 0x7e, 0x0c, 0x67, 0x3c, 0x8d, 0xe6, 0x51, 0x42, 0xd8, 0x54, 0x99, 0x45, 0x65, 0x1a, 0x3b,
	0x71, 0x28, 0x43, 0xe7, 0x50, 0x12, 0xe4, 0x96, 0x51, 0x53, 0x57, 0x66, 0x4e, 0xf0, 0x13, 0xa8,
	0xed, 0x97, 0xe6, 0x76, 0x49, 0xd9, 0xfb, 0x0d, 0x03, 0x15, 0xbb, 0x80, 0x72, 0x16, 0x2e, 0x68,
	0x4c, 0xcc, 0xb2, 0xb2, 0xb7, 0x0c, 0x9b, 0x50, 0x09, 0x89, 0x20, 0x8c, 0xcf, 0xcd, 0x8a, 0x32,
	0x76, 0x14, 0x3f, 0x84, 0x6a, 0xc8, 0x19, 0x23, 0x22, 0xe2, 0x89, 0x79, 0xd2, 0xd4, 0x5a, 0xba,
	0x7f, 0x10, 0xf0, 0x33, 0xa8, 0xcf, 0x52, 0x12, 0x4a, 0x4c, 0xd8, 0xf4, 0x2e, 0x9a, 0x47, 0x22,
	0x33, 0xab, 0x4d, 0xad, 0x75, 0xe6, 0xa3, 0x83, 0xe1, 0x28, 0x5d, 0x1e, 0xce, 0x68, 0x32, 0x17,
	0x0b, 0x13, 0x54, 0x62, 0xcb, 0xe4, 0x8d, 0x66, 0x8c, 0xcc, 0x33, 0xf3, 0x54, 0xc9, 0x39, 0xc1,
	0x57, 0x60, 0x84, 0x3c, 0x11, 0x34, 0x11, 0x53, 0x35, 0x68, 0x43, 0x99, 0xa7, 0x5b, 0x4d, 0x4e,
	0xd2, 0xfa, 0xa2, 0x41, 0x75, 0x3f, 0x57, 0x7c, 0x02, 0xfa, 0xb8, 0x3f, 0x0c, 0x90, 0x26, 0xd1,
	0x44, 0xa2, 0x02, 0x06, 0x28, 0x3b, 0xa3, 0x49, 0x67, 0xe0, 0xa2, 0x12, 0xae, 0x42, 0xa9, 0x37,
	0x18, 0xb5, 0x03, 0x54, 0x96, 0xb0, 0x73, 0x13, 0xb8, 0x63, 0x54, 0x91, 0xd9, 0xa0, 0xef, 0xb9,
	0x08, 0xb0, 0x01, 0x27, 0x4e, 0x3b, 0x70, 0x15, 0x33, 0x70, 0x05, 0x8a, 0x63, 0x37, 0x40, 0xf7,
	0x65, 0xc0, 0x1d, 0x4e, 0x3c, 0x84, 0xa4, 0xd4, 0xe9, 0x07, 0xa8, 0x8e, 0x4f, 0xa1, 0xe2, 0xb8,
	0xdd, 0xbe, 0xd7, 0x1e, 0x20, 0xac, 0xfe, 0x10, 0xc3, 0xba, 0x82, 0xa2, 0xcf, 0x3f, 0xa9, 0xab,
	0xc8, 0x42, 0xa6, 0xd6, 0x2c, 0xca, 0x8f, 0xa3, 0x88, 0x8a, 0x9c, 0x5d, 0xbf, 0x84, 0x7a, 0xf7,
	0x50, 0x7e, 0xaa, 0x0a, 0xc8, 0x43, 0xdf, 0xb8, 0x23, 0xcf, 0x0d, 0xfc, 0x9b, 0xbc, 0xf8, 0xdb,
	0xf1, 0x68, 0x88, 0x0a, 0xf2, 0xac, 0xf7, 0xde, 0x00, 0x15, 0xaf, 0x6d, 0x38, 0xff, 0x77, 0xd5,
	0xae, 0xa1, 0x8c, 0x4a, 0x8c, 0xb4, 0xa3, 0xde, 0x85, 0xce, 0xd3, 0x1f, 0x9b, 0x86, 0xf6, 0x73,
	0xd3, 0xd0, 0x7e, 0x6d, 0x1a, 0xda, 0xb7, 0xdf, 0x8d, 0x7b, 0x70, 0x19, 0xf2, 0xd8, 0x56, 0x4f,
	0xc4, 0x0e, 0x3f, 0xd8, 0xdb, 0x67, 0x72, 0xbb, 0x9a, 0xfd, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xaa,
	0x8d, 0x9f, 0x66, 0x62, 0x03, 0x00, 0x00,
}
